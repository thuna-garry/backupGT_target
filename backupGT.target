#! /bin/sh

###############################################################
# script for remote backup of local modules/shares
###############################################################
. ${0%/*}/target.conf

KEY="$1"   # a key may have been optionally specified

DATE_CMD="date -u +%Y.%m.%d-%H%Mz"
TIMESTAMP="date -u +%Y.%m.%d-%H%M%Sz"
ELAPSED_CMD="date +%s"
ELAPSED_START=`$ELAPSED_CMD`

LOGFILE="${0%/*}/target.log"

RSYNC_CONF=/tmp/backupGT_rsyncd_`$DATE_CMD`
RSYNC_CMD="rsync --server --daemon --config=$RSYNC_CONF ."


###############################################################
# utilities
###############################################################

#-------------
# find a variable assignment in a string and return the value assigned
# to the specified variable assuming an input string of the form
#     var_1=val_1  var_2=val_2 ...
#-------------
parseAssignment() {
    local var=$1

    #awk method (not always available in restricted environments)
    #awk '{ print $0 }' RS=' ' | grep "${var}=" \
    #    | awk '{ print substr($0, index($0, "=")+1) }'

    #sed method: first delete any lines not containing $var, then get the value
    sed -e "/${var}/!d" \
        -e "s/^.*${var}=\([^[:space:]]*\).*/\1/"
}

lop5offEnd () {
    #bash/cut method (bash/cut not always available in restricted environments)
    #echo $* | cut -d ' ' -f -$(( $# - 5 ))

    #sh/sed method
    list="$*"
    for i in 1 2 3 4 5; do
        list=`echo $list | sed 's/[^[:space:]]*$//'`
    done
    echo $list
}

logHeader () {
    # pass as $* the original command line
    [ "$REQUEST_MODULE" = "_listModules" ] && printf "\n\n"
    echo "===== begin ======================================================="
    echo `$TIMESTAMP`: command line = "$@"
    #echo `$TIMESTAMP`: SSH_ORIGINAL_COMMAND = "$SSH_ORIGINAL_COMMAND"
    #echo `$TIMESTAMP`: KEY = "$KEY"
    echo `$TIMESTAMP`: module spec    = "$MODULE_SPEC"
    echo `$TIMESTAMP`: request module = "$REQUEST_MODULE"
    echo `$TIMESTAMP`: request parms  = "$REQUEST_PARMS"
    echo `$TIMESTAMP`: request method = "$REQUEST_METHOD"
} >> $LOGFILE

logFooter () {
    echo "`$TIMESTAMP`: complete (duration = $ELAPSED_MIN minutes)"
    echo "===== end ========================================================="
    echo ""
} >> $LOGFILE


######################################################################
# rsync processing routines
######################################################################
module_rsync_init() {
    unset foo
}
module_rsync_fini() {
    unset foo
}
module_rsync_process() {
    module_rsync_init

    createRsyncd 
    echo "`$TIMESTAMP`: RSYNC_CMD = $RSYNC_CMD"  >> $LOGFILE
    $RSYNC_CMD                                  2>> $LOGFILE
    local rc=$?
    echo "`$TIMESTAMP`: rsync return code =" $rc                   >> $LOGFILE
    echo "`$TIMESTAMP`: rsync return desc =" `rsyncErrorCode $rc`  >> $LOGFILE
    rm -f $RSYNC_CONF

    module_rsync_fini
}

createRsyncd () {
    local module=$REQUEST_MODULE
    local path="`echo $REQUEST_PARMS | parseAssignment path`"

    if [ -z "$path" ]; then
        path=$MOD_TMP_DIR
    fi
    {
        echo ""
        echo "[ $module ]"
        echo "path = $path"
       #echo "comment = $comment"
        echo "max connections = 1"
        echo "lock file = /tmp/lock.$module"
        echo "use chroot = false"
        echo "read only = true"
        echo "list = true"
        echo "uid = 0"
        echo "gid = 0"
        echo "timeout = 600"
        echo "filter = dir-merge /$FILTER_FILE"
        echo ""
    } > $RSYNC_CONF
    cat $RSYNC_CONF >>$LOGFILE
}


rsyncErrorCode () {
    case $1 in
        0)  echo 'Success' ;;
        1)  echo 'Syntax or usage error' ;;
        2)  echo 'Protocol incompatibility' ;;
        3)  echo 'Errors selecting input/output files, dirs' ;;
        4)  echo 'Requested action not supported: an attempt was made to manipulate '   \
                 '64-bit files on a platform that cannot support them; or an option '   \
                 'was specified that is supported by the client and not by the server.' ;;
        5)  echo 'Error starting client-server protocol' ;;
        6)  echo 'Daemon unable to append to log-file' ;;
        10) echo 'Error in socket I/O' ;;
        11) echo 'Error in file I/O' ;;
        12) echo 'Error in rsync protocol data stream' ;;
        13) echo 'Errors with program diagnostics' ;;
        14) echo 'Error in IPC code' ;;
        20) echo 'Received SIGUSR1 or SIGINT' ;;
        21) echo 'Some error returned by CWwaitpid\(\)' ;;
        22) echo 'Error allocating core memory buffers' ;;
        23) echo 'Partial transfer due to error' ;;
        24) echo 'Partial transfer due to vanished source files' ;;
        25) echo 'The --max-delete limit stopped deletions' ;;
        30) echo 'Timeout in data send/receive' ;;
        35) echo 'Timeout waiting for daemon connectio' ;;
    esac
}



######################################################################
# zfs processing routines
######################################################################
module_zfs_init() {
    unset foo
}
module_zfs_fini() {
    unset foo
}
module_zfs_process() {
    module_zfs_init

    local rootDS=`         echo "$REQUEST_PARMS" | parseAssignment rootDS`
    local relDS=`          echo "$REQUEST_PARMS" | parseAssignment relDS`
    local tmpDS=`          echo "$REQUEST_PARMS" | parseAssignment tmpDS`
    local lastSnapLabel=`  echo "$REQUEST_PARMS" | parseAssignment lastSnap`
    local rc=0
    local dataset="$rootDS/$relDS"

    echo "`$TIMESTAMP`: root dataset      = $rootDS"    >> $LOGFILE
    echo "`$TIMESTAMP`: requested dataset = $relDS"     >> $LOGFILE

    if [ -z "`zfs list -H -o name $dataset`" ]; then
        echo "`$TIMESTAMP`: requested dataset $relDS does not exist"  >> $LOGFILE
        rc=1

    else
        echo "`$TIMESTAMP`:    from snapshot = $lastSnapLabel"  >> $LOGFILE
        local newSnap=`$DATE_CMD`

        echo "`$TIMESTAMP`: generating snapshot $dataset@$newSnap"  >> $LOGFILE
        zfs snapshot "$dataset@$newSnap"

        if [ -z "$lastSnapLabel" ]; then
            echo "`$TIMESTAMP`: export is FULL                      "  >> $LOGFILE
            case $REQUEST_METHOD in
                zfs)
                    echo "`$TIMESTAMP`: streaming export to remote end "  >> $LOGFILE
                    zfs send -D  "$dataset@$newSnap"
                    ;;
                zfs.rsync)
                    checkModTmp $tmpDS
                    echo "`$TIMESTAMP`: writing export to $MOD_TMP_DIR/$REQUEST_MODULE.snapExport.gz "  >> $LOGFILE
                    zfs send -D  "$dataset@$newSnap" | gzip -9 > $MOD_TMP_DIR/$REQUEST_MODULE.snapExport.gz
                    module_rsync_process 
        #todo       rm -f $MOD_TMP_DIR/$REQUEST_MODULE.snapExport.gz
                    ;;
            esac
            rc=$?

        elif zfs list -H -o name -t snapshot -d 1 -s name "$dataset" | grep -q "@${lastSnapLabel}$"; then
            echo "`$TIMESTAMP`: export is INCREMENTAL               "  >> $LOGFILE
            case $REQUEST_METHOD in
                zfs)
                    echo "`$TIMESTAMP`: streaming export to remote end "  >> $LOGFILE
                    zfs send -D -I "$dataset@$lastSnapLabel" "$dataset@$newSnap"
                    ;;
                zfs.rsync)
                    checkModTmp $tmpDS
                    echo "`$TIMESTAMP`: writing export to $MOD_TMP_DIR/$REQUEST_MODULE.snapExport.gz "  >> $LOGFILE
                    zfs send -D -I "$dataset@$lastSnapLabel" "$dataset@$newSnap" | gzip -9 > $MOD_TMP_DIR/$REQUEST_MODULE.snapExport.gz
                    module_rsync_process
         #todo      rm -f $MOD_TMP_DIR/$REQUEST_MODULE.snapExport.gz
                    ;;
            esac
            rc=$?

        else
            echo "`$TIMESTAMP`: Error: snapshot $lastSnapLabel does not exist"  >> $LOGFILE
            rc=1
        fi
    fi

    module_zfs_fini
}


checkModTmp () {
    local tmpDS=$1

    if [ -z "`zfs list -H -r -o name $tmpDS 2>/dev/null | grep $tmpDS`" ]; then
        zfs create -o quota=$TMP_DS_MAX_SIZE $tmpDS
    fi
    MOD_TMP_DIR="`zfs list -H -o mountpoint $tmpDS`"/$REQUEST_MODULE
    mkdir -p -m 750 $MOD_TMP_DIR
}


######################################################################
# main
#  - if we are in a restricted environment there may be no SSH_ORIGINAL_COMMAND
#    so we have to re-read the module spec from the modList 
#  - note information is passed from the client by using the 'ssh command'
#    but if rsync is being used it will have 5 parameters
#    '<hostname> rsync --server --daemon .' appended to it
###############################################################

if [ -n "$SSH_ORIGINAL_COMMAND" ]; then
    MODULE_SPEC="$SSH_ORIGINAL_COMMAND"
else
    MODULE_SPEC="`${0%/*}/target.modList | grep key=$KEY`"
fi 

if echo "$MODULE_SPEC" | grep -vq '	' ; then
    echo "ERROR: protocol violated MODULE_SPEC missing tab delimeter" >> $LOGFILE
fi
REQUEST_MODULE=`echo "$MODULE_SPEC" | sed 's/\(.*\)	\(.*\)/\1/'`   #cut -d "	" -f 1
REQUEST_PARMS=` echo "$MODULE_SPEC" | sed 's/\(.*\)	\(.*\)/\2/'`   #cut -d "	" -f 2
REQUEST_METHOD=`echo "$REQUEST_PARMS" | parseAssignment method`
logHeader "$0" "$@"

if [ "$REQUEST_MODULE" =  "_listModules" ]; then
    echo "`$TIMESTAMP`: listing modules"  >> $LOGFILE
    if [ -z  "$REQUEST_PARMS" ]; then
        ${0%/*}/target.modList
    else
        ${0%/*}/target.modList | grep "^$REQUEST_PARMS"
    fi
else
    if [ -f "${0%/*}/$REQUEST_MODULE.procs" ]; then
        . "${0%/*}/$REQUEST_MODULE.procs"
    fi
    case $REQUEST_METHOD in
        rsync)          module_rsync_process ;;
        tar)            ;;
        zfs|zfs.rsync)  module_zfs_process ;;
    esac
fi

ELAPSED_END=`$ELAPSED_CMD`
ELAPSED_MIN=$(( (ELAPSED_END - ELAPSED_START) / 60 ))
logFooter
        
        
###############################################################
# cleanup
###############################################################


exit
#==========================================================================
#     1     SIGHUP       terminate process    terminal line hangup
#     2     SIGINT       terminate process    interrupt program
#     3     SIGQUIT      create core image    quit program
#     4     SIGILL       create core image    illegal instruction
#     5     SIGTRAP      create core image    trace trap
#     6     SIGABRT      create core image    abort program (formerly SIGIOT)
#     7     SIGEMT       create core image    emulate instruction executed
#     8     SIGFPE       create core image    floating-point exception
#     9     SIGKILL      terminate process    kill program
#     10    SIGBUS       create core image    bus error
#     11    SIGSEGV      create core image    segmentation violation
#     12    SIGSYS       create core image    non-existent system call invoked
#     13    SIGPIPE      terminate process    write on a pipe with no reader
#     14    SIGALRM      terminate process    real-time timer expired
#     15    SIGTERM      terminate process    software termination signal
#     16    SIGURG       discard signal       urgent condition present on socket
#     17    SIGSTOP      stop process         stop (cannot be caught or ignored)
#     18    SIGTSTP      stop process         stop signal generated from keyboard
#     19    SIGCONT      discard signal       continue after stop
#     20    SIGCHLD      discard signal       child status has changed
#     21    SIGTTIN      stop process         background read attempted from control terminal
#     22    SIGTTOU      stop process         background write attempted to control terminal
#     23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))
#     24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))
#     25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))
#     26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))
#     27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))
#     28    SIGWINCH     discard signal       Window size change
#     29    SIGINFO      discard signal       status request from keyboard
#     30    SIGUSR1      terminate process    User defined signal 1
#     31    SIGUSR2      terminate process    User defined signal 2
#==========================================================================

